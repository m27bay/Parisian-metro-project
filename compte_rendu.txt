Compte rendu du projet :

	Le projet a été codé en Java car c'est un langage modulable, il n'y a pas les problèmes de gestion de mémoire, grâce au "garbage collector", ou de problème de gestion de pointeurs. De plus le Java contient une vaste bibliothèque de fonctions et d'outil permettant de simplifier le code, comme la classe String faciltant beaucoup la lecture dans le fichier, ainsi que le manipulation de chaine de
caratères .
	

	Dans cette première partie nous présenterons les structures de données choisies ( appelées objets dans le langage Java ).

	Les temps entre les stations ainsi que le numéro des stations présents dans le fichier "MetroL.txt" sont stockés dans un objet "Matrice" implémenté dans le fichier 'Matrice.java'.  Les indices "ligne", "colonne" représentent les stations par leurs numéros dans le fichier "MetroL.txt", ainsi la station Abbesse est la station d'indice 0, celle d'Alexandre Dumas la numéro 1, etc...
Comme dit précédemment la matrice contient les temps entre les stations, pour connaître le temps entre la station 0 et 1, on peut regarder soit aux coordonnées (0,1), soit (1,0) de la matrice car le trajet peut se faire dans les deux sens.
Exception faite pour certain trajet comme par exemple la fin de la station 7b ( c'est à dire la boucle entre Botzaris et Pré-Saint-Gervais ) et la ligne 10 (entre Boulogne Jean Jaurès et Javel-André Citroën ), ou nous avons seul sens de circulation en fonction de la direction.

	L'algorithme de Dijkstra est contenu dans la classe "TblDijkstra.java". Il contient tout ce qui est nécessaire à l'algorithme et les résultats de celui-ci, tel que : 
	- La matrice de temps entre les stations.
	- Le numéro de station de départ et celui d'arrivée.
	- Un tableau de vérification de chaque station pour savoir si le plus court chemin pour atteindre la station a été trouvé.
	- Le tableau des plus courtes distances entre la station de départ et les autres, appelé 'dist'.
	- Le tableau des pères (numéro de station) de chaque station obtenu par l'algorithme de Dijkstra, appelé 'father'.
	- Notre chemin sous forme de tableau contenant l'ordre des stations, appelé 'way'.
Dans chacun des tableaux l'indice correspond au numéro de la station.

	Des "getters", des méthodes spécifiques au java parmetant d'obtenir un attribut en qui déclaré en 'private', sont présent pour récupérer le temps de parcours et le tableau de chemin. La création de l'objet 'TblDijkstra' se fait à partir de la matrice de temps entre toutes les stations, lors de la création toutes les stations sont déclarées non-traité dans chacun des tableaux. Un "non-traité" dans le tableau de vérification signifie que le plus court temps entre la station de départ et celle d'arrivée n'a pas été trouvé, dans le tableau de distance cela signifie que la station n'a pas était encore rencontré dans l'algorithme ( équivalent de distance infini), dans celui des pères cela signifie que le père n'a pas encore été déterminé. Le fonctionnement des différentes fonctions pour l'algorithme sera précisé plus loin.

///// Mettez vos parties pour les structures de données /////


	Dans cette seconde partie nous expliquerons le fonctionnement des méthodes pour calculer le temps le plus court entre deux stations. 

	La méthode 'Calcul()' ( station départ, station d'arrivée ) permet de calculer le temps le plus court entre la station de départ et toutes les autres stations. Tout d'abord, dans cette méthode, seul le temps entre les stations voisines et celle de départ est ajouté au tableau 'dist', la station de départ est déclaré "traité" ( dès que une station est "traité" on ne touche plus à la valeur dans le tableau 'dist', tableau contenant les plus petits temps, car c'est la plus petite valeur possible ) et son père est à '-1' ( équivalent à ne pas avoir de père). Tant que toutes les stations n'ont pas était déclaré "traité" ( Méthode 'finished()' ) et qu'il existe au moins une station atteignable ont continu de calculer le temps le plus court. Nous chercherons à chaque fois la station ayant le temps le plus court avec l'origine parmi les stations 'non-traité' grâce à la méthode 'min()', avant de la déclaré "traité". A partir de cette station on utilise la méthode 'treatment()' qui actualise le temps entre notre station et les stations voisines si le temps trouvé ( temps[origine - station] + temps[station - voisin] ) est plus court que celui dans le tableau 'dist' ou si la station n'a pas était rencontrée auparavant. Si le temps d'une station est actualisé alors la station trouvé par 'min()' est déclaré "père" de celle-ci. Dès que tous les sommets ont été traités, on utilise la méthode 'CalculWay()' qui renvoie le tableau des numéros des stations à prendre. Pour trouver le chemin, on stocke les pères en partant de la station d'arrivée jusqu'à la station de départ, puis on inverse l'ordre.
