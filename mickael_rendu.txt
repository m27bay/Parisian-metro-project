Rapport projet algorithme des graphes
Ma partie :
	- Lire le fichiers de configuration afin de créer une matrice avec toutes les stations et les distances pour pouvoir appliquer Dijkstra.
	- Création des structures de données pour pouvoir stocker les stations, les voyages, les lignes de métros et le métro dans sa globalité.

Explication globale:
Première partie: Lire le fichiers de configuration afin de créer une matrice avec toutes les stations et les distances pour pouvoir appliquer Dijkstra.

Cette partie concerne le fichier ' TblStation.java ' ( 200 lignes ).
Ce dernier étant composé de:
	Trois attributs qui sont :
		- private final int tblSize 		// Le taille du tableau.
		- private final String dataFile 	// Le fichier de configuration.
		- private final int tbl[ ][ ]		// Le tableau rempli.

	D'un constructeur, qui instancie une variable de type TblStation:
		public TblStations( String dataFile ) throws IOExeptions.
			this.dataFile = dataFile;
			this.tblSize = stationCount() + 1; // Methode qui compte le nombre de station.
			this.tbl = new int[ this.tblSize ][ this.tblSize ];


	Et de plusieurs methodes:
		public int[][] getTbl() // Retourn le tableau.
		private int stationCount() // Compte le nombre de station.
		public void fillTravelTime().
		// Permet de remplir le tableau avec des -1 si la distance entre deux stations n'est pas définie.
		// Permet aussi de remplir la diagonale avec des 0, cela correspond donc à la distance entre une station et elle même.
		// Enfin, si la distance entre la station i et j est définie remplie la case [i][j] ainsi que la case [j][i]
		// sauf pour une partie de la ligne 7 et de la ligne 10, où nous avons un trajet différent en fonction du sens de circulation.
		public void print().

Deuxième partie: Créations de structures de données pour pouvoir stocker les stations, les voyages; les lignes de métros et le métro dans sa globalté.
Pour commencer nous avons la classe 'Station.java' qui est constituée de la manière suivante ( 108 lignes ):
	Nous avons donc les attributs suivants:
		private final String name.
		private final int number.
		private final boolean isTerminus; // Indiquant si oui ou non la station est un terminus.

	Puis nous avons les constructeurs:
		public Station() // Constructeur par défaut.
		public Station( String name, int number, boolean isTerminus ).

	Et enfin les methodes:
		public String getName() // Retourne le nom de la station.
		public int getNumber() // Retourne le numéro de la station.
		public boolean getIsTerminus() // Retourne si oui ou non la station est un terminus.
		public String toString() // Retourne une String avec le nom, le numéro, et le booléen 'isTerminus' de la station.
		public boolean equals( Station other ). // Retourne un booléen indiquant si les deux stations sont égales.
		public Station copy(). // Retourne une copie de la station.

Ensuite nous avons la class 'Travel.java', représentant un voyage entre deux stations, implémenté comme suit ( 162 lignes ):
	On commence par les attributs:
		private Station stationStart, stationStop. // La station de départ et la station d'arrivée, sens prendre en compte le sens de direction.
		private int time. // Le temps de voyage entre ces deux stations.

	S'en suit les constructeurs:
		public Travel() // Le constructeur par défaut.
		public Travel( Station stationStart, Station stationStop, int time ).

	Suivie par les méthodes:
		public int getNumStationStart() // Retourne le numero de la station de départ.
		public Station getStationStart() // Retourne la station de départ.
		public void setStationStart( Station stationStart ) // Modifie la station de départ.

		public int getNumStationStop() // Retourne le numero de la station d'arrivée.
		public Station getStationStop() // Retourne la station d'arrivée.
		public void setStationStop( Station stationStop ) // Modifie la station d'arrivée.

		public int getTime() // Retourne le temps de trajet.
		public void setTime( int time ) // Modifie le temps de trajet.

		public Travel switchStation() // Inverse la station de départ avec la station d'arrivée.
		public boolean equals( Travel other ) // Retourne un booléen indiquant si les deux trajet sont égaux.
		public String toString() // Retourne une String avec les informtions sur les deux stations et le temps de trajet.

Puis, arrive la classe 'MetroLine.java', qui représente une ligne de métro, écrite de cette façon ( 132 lignes ):
	Elle posède les attributs suivants;
		private String name // Le nom de la ligne de métro.
		private ArrayList < Station > listStation // La liste des stations présentes dans la ligne.
		private ArrayList < Travel > listTravel // La liste des trajets.

	Nous instancions cette classe par le constructeur suivant:
		public MetroLine().

	Et pour finir les méthodes:
		public String getName() // Retourne le le nom de la ligne.
		public void setName( String newName ). // Change le nom de ligne.
		public ArrayList < Station > getListStation() // Retourne la liste des stations.
		public ArrayList < Travel > getListTravel() // Retourne la liste des trajets.
		public void setListTravel( ArrayList < Travel > _new ) // Modifie la liste de trajet.

		public void addStation( Station _new ) // Ajoute une nouvelle station à la liste de station.
		public void addTravel( Travel _new ) // Ajoute un nouveau trajet à la liste de trajet.

		public void printStation() // Affiche toutes les stations de la ligne.
		public void printTravel() // Afficher tous les trajets de la ligne.

Nous finissons par la classe 'Metro.java', qui manipule les précédentes classes et qui est la partie majeur de mon travail ( 895 lignes ) :
	Elle est définie ainsi :
		private final MetroLine[] metro // Le tableau de ligne de métro.
		private final String dataFile // Le nom du fichier de configuration.

	Vient ensuite le constructeur :
		public Metro( String dataFile ) // Initialise le tableau metro avec une taille de 16 ( 14 lignes + 3b et 7b ).


	Et pour conclure les méthodes:
		private Station whatStation( int numStation ) // Retourne la Station correspondant au numéro.
		public int convertNameToNumStation( String nameStation ) // Retourn le numéro d'une station correspondant à son nom.
		private String whatMetroLine( int numStation )
		// Retourne le nom de la ligne de métro sur laquelle est la station caractérisée par son numéro.

		private int strLineToInt( String line ) // Converti le nom de la ligne en indice pour avoir ça position dans le tableau.
		private String intToStrLine( int line ) // Converti l'indice de la ligne en son nom.

		public void initLine() // Initialise la liste de stations et la liste de trajets.
		public void initLineStation() // Initialise la liste de stations.
		public void initLineTravel() // Initialise la liste de trajets

		public void sortTravel() // Trie toutes les listes de trajets.
MODIFIER public void sortIndexTravel( int index )
		// Trie la liste de trajets de la ligne 'index'.
		// On part du premier trajet que l'on voit et on l'ajoute dans la liste chaînée.
		// Puis une regarde le trajet suivant et on essaie de l'aligner avec le précédent trajet, c'est à dire si le précédent est : A B ( on part de A vers B ) si pour le trajet suivant on remarque qu'il
		// part de A ou arrive à A on l'ajoute à la tête de la liste afin d'avoir X A => A B dans la liste, et si le trajet suivant on part de B ou arrive de B on l'ajoute à la fin de la liste pour avoir
		// A B => B Y ( X et Y étant d'autres stations ), on continue cela jusque'à avoir vu tous les éléments de la liste de trajets.

		public String knowDirection( int[] way, int pos, int numLine, int wayLength )
		// Retourne la direction à prendre pour la suite du trajet, en fonction du tableau de station à empreinter 'way', de la position ou l'on si situe 'pos', du numéro de la ligne 'numLine'.

MODIFIER public String knowDirectionRight( int numStationStart, int numStationStop, int numLine )
        // Retourne la direction si la ligne est droite.
		// Cette méthode fait appel à la méthode 'sortIndexTravel' et renvoie soit le premier élément de la liste trié soit le dernière, puisque en sortant de la méthode 'sortIndexTravel' on a placé
		// les terminus en début et en fin de liste.
		// Sauf pour la 7b ou le terminus et au millieu.

        private String[] fillTbl( String metroLine )
		// Retourne un tableau de String composé de tous les voyages possibles sur la ligne 'metroLine'.

MODIFIER public String knowDirectionFork( int[] way, int pos, int wayLength )
		// Retourne la direction si la ligne n'est pas droite (fourche et boucle), en fonction du tableau de station à empreinter 'way', de la position ou l'on si situe 'pos'.
		// On lit dans le fichier chaque transition en partant de la ou nous sommes en bloquant la transition pour revenir en arrière et on s'arrête que lorsque l'on tombe sur un terminus.
		// Elle fait appel a fillTbl ce qui nou sassure de ne pas avoir un terminus d'une autre ligne.

MODIFIER public void printTravelDetail( int way[], int wayLength, String time ) // Affiche le trajet que doit prendre l'utilisateur et fait appel à 'writeDataFile() pour écrire les informations'.

		public void printStation() // Affiche toutes les stations.
		public void printIndexStation( String index )
		// Affiche toutes les stations dans la ligne qui est situé dans le tableau à la position 'index'.

		public void printTravel() // Affiche tous les trajets.
		public void printIndexTravel( String index )
		// Affiche tous les trajets possibles sur la ligne qui est situé dans le tableau à la position 'index'.

		public void writeDataFile( String UserTravelFile, String[] data )
		// Ecrit un fichier avec les informations du voyages utilisé pour l'affichage de la partie graphique.

MODIFER
Comment s'articule le tout ?
    Le centre de mon travail est la fonction 'printTravelDetail' qui récupère les informations produites par l'algorithme de dijkstra, affiche les stations en fonctions de leurs numéros ainsi que les
    lignes de métros via le même procédé. Elle est en charge aussi de trouvé et d'afficher les terminus.